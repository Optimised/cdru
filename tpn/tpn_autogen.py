#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Feb 04 10:09:07 2015 by generateDS.py version 2.14a.
#
# Command line options:
#   ('-o', 'tpn_autogen.py')
#
# Command line arguments:
#   tpn.xsd
#
# Command line:
#   generateDS.py -o "tpn_autogen.py" tpn.xsd
#
# Current working directory (os.getcwd()):
#   generateDS-2.14a
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
import math

Validate_simpletypes_ = True


etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            if math.isinf(input_data):
                if input_data > 0:
                    return 'INF'
                else:
                    return '-INF'
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class decision_variable_equals(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, variable=None, value=None):
        self.original_tagname_ = None
        self.variable = variable
        self.value = value
    def factory(*args_, **kwargs_):
        if decision_variable_equals.subclass:
            return decision_variable_equals.subclass(*args_, **kwargs_)
        else:
            return decision_variable_equals(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_variable(self): return self.variable
    def set_variable(self, variable): self.variable = variable
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.variable is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='decision-variable-equals', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='decision-variable-equals')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='decision-variable-equals', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='decision-variable-equals'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='decision-variable-equals', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.variable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svariable>%s</%svariable>%s' % (namespace_, self.gds_format_string(quote_xml(self.variable), input_name='variable'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value), input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='decision-variable-equals'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.variable is not None:
            showIndent(outfile, level)
            outfile.write('variable=%s,\n' % quote_python(self.variable))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'variable':
            variable_ = child_.text
            variable_ = self.gds_validate_string(variable_, node, 'variable')
            self.variable = variable_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class decision_variable_equals


class state_variable_value_at(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, variable=None, event=None):
        self.original_tagname_ = None
        self.variable = variable
        self.event = event
    def factory(*args_, **kwargs_):
        if state_variable_value_at.subclass:
            return state_variable_value_at.subclass(*args_, **kwargs_)
        else:
            return state_variable_value_at(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_variable(self): return self.variable
    def set_variable(self, variable): self.variable = variable
    def get_event(self): return self.event
    def set_event(self, event): self.event = event
    def hasContent_(self):
        if (
            self.variable is not None or
            self.event is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='state-variable-value-at', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='state-variable-value-at')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='state-variable-value-at', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='state-variable-value-at'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='state-variable-value-at', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.variable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svariable>%s</%svariable>%s' % (namespace_, self.gds_format_string(quote_xml(self.variable), input_name='variable'), namespace_, eol_))
        if self.event is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sevent>%s</%sevent>%s' % (namespace_, self.gds_format_string(quote_xml(self.event), input_name='event'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='state-variable-value-at'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.variable is not None:
            showIndent(outfile, level)
            outfile.write('variable=%s,\n' % quote_python(self.variable))
        if self.event is not None:
            showIndent(outfile, level)
            outfile.write('event=%s,\n' % quote_python(self.event))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'variable':
            variable_ = child_.text
            variable_ = self.gds_validate_string(variable_, node, 'variable')
            self.variable = variable_
        elif nodeName_ == 'event':
            event_ = child_.text
            event_ = self.gds_validate_string(event_, node, 'event')
            self.event = event_
# end class state_variable_value_at


class state_variable_guard_value(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, constant=None, state_variable_at=None):
        self.original_tagname_ = None
        self.constant = constant
        self.state_variable_at = state_variable_at
    def factory(*args_, **kwargs_):
        if state_variable_guard_value.subclass:
            return state_variable_guard_value.subclass(*args_, **kwargs_)
        else:
            return state_variable_guard_value(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_constant(self): return self.constant
    def set_constant(self, constant): self.constant = constant
    def get_state_variable_at(self): return self.state_variable_at
    def set_state_variable_at(self, state_variable_at): self.state_variable_at = state_variable_at
    def hasContent_(self):
        if (
            self.constant is not None or
            self.state_variable_at is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='state-variable-guard-value', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='state-variable-guard-value')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='state-variable-guard-value', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='state-variable-guard-value'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='state-variable-guard-value', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.constant is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconstant>%s</%sconstant>%s' % (namespace_, self.gds_format_string(quote_xml(self.constant), input_name='constant'), namespace_, eol_))
        if self.state_variable_at is not None:
            self.state_variable_at.export(outfile, level, namespace_, name_='state-variable-at', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='state-variable-guard-value'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.constant is not None:
            showIndent(outfile, level)
            outfile.write('constant=%s,\n' % quote_python(self.constant))
        if self.state_variable_at is not None:
            showIndent(outfile, level)
            outfile.write('state_variable_at=model_.state_variable_value_at(\n')
            self.state_variable_at.exportLiteral(outfile, level, name_='state_variable_at')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'constant':
            constant_ = child_.text
            constant_ = self.gds_validate_string(constant_, node, 'constant')
            self.constant = constant_
        elif nodeName_ == 'state-variable-at':
            obj_ = state_variable_value_at.factory()
            obj_.build(child_)
            self.state_variable_at = obj_
            obj_.original_tagname_ = 'state-variable-at'
# end class state_variable_guard_value


class state_variable_guard_boolean_expr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, condition=None, value=None):
        self.original_tagname_ = None
        self.condition = condition
        if value is None:
            self.value = []
        else:
            self.value = value
    def factory(*args_, **kwargs_):
        if state_variable_guard_boolean_expr.subclass:
            return state_variable_guard_boolean_expr.subclass(*args_, **kwargs_)
        else:
            return state_variable_guard_boolean_expr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value_at(self, index, value): self.value.insert(index, value)
    def replace_value_at(self, index, value): self.value[index] = value
    def hasContent_(self):
        if (
            self.condition is not None or
            self.value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='state-variable-guard-boolean-expr', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='state-variable-guard-boolean-expr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='state-variable-guard-boolean-expr', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='state-variable-guard-boolean-expr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='state-variable-guard-boolean-expr', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.condition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scondition>%s</%scondition>%s' % (namespace_, self.gds_format_string(quote_xml(self.condition), input_name='condition'), namespace_, eol_))
        for value_ in self.value:
            value_.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='state-variable-guard-boolean-expr'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.condition is not None:
            showIndent(outfile, level)
            outfile.write('condition=%s,\n' % quote_python(self.condition))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('model_.state_variable_guard_value(\n')
            value_.exportLiteral(outfile, level, name_='state-variable-guard-value')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'condition':
            condition_ = child_.text
            condition_ = self.gds_validate_string(condition_, node, 'condition')
            self.condition = condition_
        elif nodeName_ == 'value':
            obj_ = state_variable_guard_value.factory()
            obj_.build(child_)
            self.value.append(obj_)
            obj_.original_tagname_ = 'value'
# end class state_variable_guard_boolean_expr


class guard_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, guard=None):
        self.original_tagname_ = None
        if guard is None:
            self.guard = []
        else:
            self.guard = guard
    def factory(*args_, **kwargs_):
        if guard_list.subclass:
            return guard_list.subclass(*args_, **kwargs_)
        else:
            return guard_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_guard(self): return self.guard
    def set_guard(self, guard): self.guard = guard
    def add_guard(self, value): self.guard.append(value)
    def insert_guard_at(self, index, value): self.guard.insert(index, value)
    def replace_guard_at(self, index, value): self.guard[index] = value
    def hasContent_(self):
        if (
            self.guard
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='guard-list', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='guard-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='guard-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='guard-list'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='guard-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for guard_ in self.guard:
            guard_.export(outfile, level, namespace_, name_='guard', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='guard-list'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('guard=[\n')
        level += 1
        for guard_ in self.guard:
            showIndent(outfile, level)
            outfile.write('model_.guard(\n')
            guard_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'guard':
            obj_ = guard.factory()
            obj_.build(child_)
            self.guard.append(obj_)
            obj_.original_tagname_ = 'guard'
# end class guard_list


class guard(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, boolean_constant=None, decision_variable_equals=None, state_variable_guard=None, and_=None, or_=None, not_=None):
        self.original_tagname_ = None
        self.boolean_constant = boolean_constant
        self.decision_variable_equals = decision_variable_equals
        self.state_variable_guard = state_variable_guard
        self.and_ = and_
        self.or_ = or_
        self.not_ = not_
    def factory(*args_, **kwargs_):
        if guard.subclass:
            return guard.subclass(*args_, **kwargs_)
        else:
            return guard(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_boolean_constant(self): return self.boolean_constant
    def set_boolean_constant(self, boolean_constant): self.boolean_constant = boolean_constant
    def get_decision_variable_equals(self): return self.decision_variable_equals
    def set_decision_variable_equals(self, decision_variable_equals): self.decision_variable_equals = decision_variable_equals
    def get_state_variable_guard(self): return self.state_variable_guard
    def set_state_variable_guard(self, state_variable_guard): self.state_variable_guard = state_variable_guard
    def get_and(self): return self.and_
    def set_and(self, and_): self.and_ = and_
    def get_or(self): return self.or_
    def set_or(self, or_): self.or_ = or_
    def get_not(self): return self.not_
    def set_not(self, not_): self.not_ = not_
    def hasContent_(self):
        if (
            self.boolean_constant is not None or
            self.decision_variable_equals is not None or
            self.state_variable_guard is not None or
            self.and_ is not None or
            self.or_ is not None or
            self.not_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='guard', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='guard')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='guard', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='guard'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='guard', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.boolean_constant is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sboolean-constant>%s</%sboolean-constant>%s' % (namespace_, self.gds_format_boolean(self.boolean_constant, input_name='boolean-constant'), namespace_, eol_))
        if self.decision_variable_equals is not None:
            self.decision_variable_equals.export(outfile, level, namespace_, name_='decision-variable-equals', pretty_print=pretty_print)
        if self.state_variable_guard is not None:
            self.state_variable_guard.export(outfile, level, namespace_, name_='state-variable-guard', pretty_print=pretty_print)
        if self.and_ is not None:
            self.and_.export(outfile, level, namespace_, name_='and', pretty_print=pretty_print)
        if self.or_ is not None:
            self.or_.export(outfile, level, namespace_, name_='or', pretty_print=pretty_print)
        if self.not_ is not None:
            self.not_.export(outfile, level, namespace_, name_='not', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='guard'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.boolean_constant is not None:
            showIndent(outfile, level)
            outfile.write('boolean_constant=%s,\n' % self.boolean_constant)
        if self.decision_variable_equals is not None:
            showIndent(outfile, level)
            outfile.write('decision_variable_equals=model_.decision_variable_equals(\n')
            self.decision_variable_equals.exportLiteral(outfile, level, name_='decision_variable_equals')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.state_variable_guard is not None:
            showIndent(outfile, level)
            outfile.write('state_variable_guard=model_.state_variable_guard_boolean_expr(\n')
            self.state_variable_guard.exportLiteral(outfile, level, name_='state_variable_guard')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.and_ is not None:
            showIndent(outfile, level)
            outfile.write('and_=model_.guard_list(\n')
            self.and_.exportLiteral(outfile, level, name_='and')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.or_ is not None:
            showIndent(outfile, level)
            outfile.write('or_=model_.guard_list(\n')
            self.or_.exportLiteral(outfile, level, name_='or')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.not_ is not None:
            showIndent(outfile, level)
            outfile.write('not_=model_.notType(\n')
            self.not_.exportLiteral(outfile, level, name_='not')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'boolean-constant':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'boolean_constant')
            self.boolean_constant = ival_
        elif nodeName_ == 'decision-variable-equals':
            obj_ = decision_variable_equals.factory()
            obj_.build(child_)
            self.decision_variable_equals = obj_
            obj_.original_tagname_ = 'decision-variable-equals'
        elif nodeName_ == 'state-variable-guard':
            obj_ = state_variable_guard_boolean_expr.factory()
            obj_.build(child_)
            self.state_variable_guard = obj_
            obj_.original_tagname_ = 'state-variable-guard'
        elif nodeName_ == 'and':
            obj_ = guard_list.factory()
            obj_.build(child_)
            self.and_ = obj_
            obj_.original_tagname_ = 'and'
        elif nodeName_ == 'or':
            obj_ = guard_list.factory()
            obj_.build(child_)
            self.or_ = obj_
            obj_.original_tagname_ = 'or'
        elif nodeName_ == 'not':
            obj_ = notType.factory()
            obj_.build(child_)
            self.not_ = obj_
            obj_.original_tagname_ = 'not'
# end class guard


class variable_domain(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, finite_domain=None, continuous_domain=None):
        self.original_tagname_ = None
        self.finite_domain = finite_domain
        self.continuous_domain = continuous_domain
    def factory(*args_, **kwargs_):
        if variable_domain.subclass:
            return variable_domain.subclass(*args_, **kwargs_)
        else:
            return variable_domain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_finite_domain(self): return self.finite_domain
    def set_finite_domain(self, finite_domain): self.finite_domain = finite_domain
    def get_continuous_domain(self): return self.continuous_domain
    def set_continuous_domain(self, continuous_domain): self.continuous_domain = continuous_domain
    def hasContent_(self):
        if (
            self.finite_domain is not None or
            self.continuous_domain is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='variable-domain', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='variable-domain')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='variable-domain', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='variable-domain'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='variable-domain', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.finite_domain is not None:
            self.finite_domain.export(outfile, level, namespace_, name_='finite-domain', pretty_print=pretty_print)
        if self.continuous_domain is not None:
            self.continuous_domain.export(outfile, level, namespace_, name_='continuous-domain', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='variable-domain'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.finite_domain is not None:
            showIndent(outfile, level)
            outfile.write('finite_domain=model_.finite_variable_domain(\n')
            self.finite_domain.exportLiteral(outfile, level, name_='finite_domain')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.continuous_domain is not None:
            showIndent(outfile, level)
            outfile.write('continuous_domain=model_.continuous_variable_domain(\n')
            self.continuous_domain.exportLiteral(outfile, level, name_='continuous_domain')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'finite-domain':
            obj_ = finite_variable_domain.factory()
            obj_.build(child_)
            self.finite_domain = obj_
            obj_.original_tagname_ = 'finite-domain'
        elif nodeName_ == 'continuous-domain':
            obj_ = continuous_variable_domain.factory()
            obj_.build(child_)
            self.continuous_domain = obj_
            obj_.original_tagname_ = 'continuous-domain'
# end class variable_domain


class range_(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lower_bound=None, upper_bound=None):
        self.original_tagname_ = None
        self.lower_bound = lower_bound
        self.upper_bound = upper_bound
    def factory(*args_, **kwargs_):
        if range_.subclass:
            return range_.subclass(*args_, **kwargs_)
        else:
            return range_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lower_bound(self): return self.lower_bound
    def set_lower_bound(self, lower_bound): self.lower_bound = lower_bound
    def get_upper_bound(self): return self.upper_bound
    def set_upper_bound(self, upper_bound): self.upper_bound = upper_bound
    def hasContent_(self):
        if (
            self.lower_bound is not None or
            self.upper_bound is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='range', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='range')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='range', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='range'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='range', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lower_bound is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slower-bound>%s</%slower-bound>%s' % (namespace_, self.gds_format_double(self.lower_bound, input_name='lower-bound'), namespace_, eol_))
        if self.upper_bound is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%supper-bound>%s</%supper-bound>%s' % (namespace_, self.gds_format_double(self.upper_bound, input_name='upper-bound'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='range'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.lower_bound is not None:
            showIndent(outfile, level)
            outfile.write('lower_bound=%e,\n' % self.lower_bound)
        if self.upper_bound is not None:
            showIndent(outfile, level)
            outfile.write('upper_bound=%e,\n' % self.upper_bound)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lower-bound':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'lower_bound')
            self.lower_bound = fval_
        elif nodeName_ == 'upper-bound':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'upper_bound')
            self.upper_bound = fval_
# end class range_


class continuous_variable_domain(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, range_=None):
        self.original_tagname_ = None
        if range_ is None:
            self.range_ = []
        else:
            self.range_ = range_
    def factory(*args_, **kwargs_):
        if continuous_variable_domain.subclass:
            return continuous_variable_domain.subclass(*args_, **kwargs_)
        else:
            return continuous_variable_domain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_range(self): return self.range_
    def set_range(self, range_): self.range_ = range_
    def add_range(self, value): self.range_.append(value)
    def insert_range_at(self, index, value): self.range_.insert(index, value)
    def replace_range_at(self, index, value): self.range_[index] = value
    def hasContent_(self):
        if (
            self.range_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='continuous-variable-domain', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='continuous-variable-domain')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='continuous-variable-domain', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='continuous-variable-domain'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='continuous-variable-domain', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for range_ in self.range_:
            range_.export(outfile, level, namespace_, name_='range', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='continuous-variable-domain'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('range_=[\n')
        level += 1
        for range_ in self.range_:
            showIndent(outfile, level)
            outfile.write('model_.range_(\n')
            range_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'range':
            obj_ = range_.factory()
            obj_.build(child_)
            self.range_.append(obj_)
            obj_.original_tagname_ = 'range'
# end class continuous_variable_domain


class finite_variable_domain(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None):
        self.original_tagname_ = None
        if value is None:
            self.value = []
        else:
            self.value = value
    def factory(*args_, **kwargs_):
        if finite_variable_domain.subclass:
            return finite_variable_domain.subclass(*args_, **kwargs_)
        else:
            return finite_variable_domain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value_at(self, index, value): self.value.insert(index, value)
    def replace_value_at(self, index, value): self.value[index] = value
    def hasContent_(self):
        if (
            self.value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='finite-variable-domain', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='finite-variable-domain')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='finite-variable-domain', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='finite-variable-domain'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='finite-variable-domain', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_), input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='finite-variable-domain'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
# end class finite_variable_domain


class guarded_tn_member(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, guard=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = id
        self.name = name
        self.guard = guard
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if guarded_tn_member.subclass:
            return guarded_tn_member.subclass(*args_, **kwargs_)
        else:
            return guarded_tn_member(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_guard(self): return self.guard
    def set_guard(self, guard): self.guard = guard
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.guard is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='guarded-tn-member', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='guarded-tn-member')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='guarded-tn-member', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='guarded-tn-member'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='guarded-tn-member', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_string(quote_xml(self.id), input_name='id'), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name), input_name='name'), namespace_, eol_))
        if self.guard is not None:
            self.guard.export(outfile, level, namespace_, name_='guard', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='guarded-tn-member'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % quote_python(self.id))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name))
        if self.guard is not None:
            showIndent(outfile, level)
            outfile.write('guard=model_.guard(\n')
            self.guard.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id = id_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'guard':
            obj_ = guard.factory()
            obj_.build(child_)
            self.guard = obj_
            obj_.original_tagname_ = 'guard'
# end class guarded_tn_member


class dispatchable_guarded_tn_member(guarded_tn_member):
    subclass = None
    superclass = guarded_tn_member
    def __init__(self, id=None, name=None, guard=None, dispatch=None, extensiontype_=None):
        self.original_tagname_ = None
        super(dispatchable_guarded_tn_member, self).__init__(id, name, guard, extensiontype_, )
        self.dispatch = dispatch
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if dispatchable_guarded_tn_member.subclass:
            return dispatchable_guarded_tn_member.subclass(*args_, **kwargs_)
        else:
            return dispatchable_guarded_tn_member(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dispatch(self): return self.dispatch
    def set_dispatch(self, dispatch): self.dispatch = dispatch
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.dispatch is not None or
            super(dispatchable_guarded_tn_member, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dispatchable-guarded-tn-member', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dispatchable-guarded-tn-member')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dispatchable-guarded-tn-member', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dispatchable-guarded-tn-member'):
        super(dispatchable_guarded_tn_member, self).exportAttributes(outfile, level, already_processed, namespace_, name_='dispatchable-guarded-tn-member')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='dispatchable-guarded-tn-member', fromsubclass_=False, pretty_print=True):
        super(dispatchable_guarded_tn_member, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dispatch is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdispatch>%s</%sdispatch>%s' % (namespace_, self.gds_format_string(quote_xml(self.dispatch), input_name='dispatch'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='dispatchable-guarded-tn-member'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(dispatchable_guarded_tn_member, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(dispatchable_guarded_tn_member, self).exportLiteralChildren(outfile, level, name_)
        if self.dispatch is not None:
            showIndent(outfile, level)
            outfile.write('dispatch=%s,\n' % quote_python(self.dispatch))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(dispatchable_guarded_tn_member, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dispatch':
            dispatch_ = child_.text
            dispatch_ = self.gds_validate_string(dispatch_, node, 'dispatch')
            self.dispatch = dispatch_
        super(dispatchable_guarded_tn_member, self).buildChildren(child_, node, nodeName_, True)
# end class dispatchable_guarded_tn_member


class decision_variable(guarded_tn_member):
    subclass = None
    superclass = guarded_tn_member
    def __init__(self, id=None, name=None, guard=None, type_=None, domain=None):
        self.original_tagname_ = None
        super(decision_variable, self).__init__(id, name, guard, )
        self.type_ = type_
        self.domain = domain
    def factory(*args_, **kwargs_):
        if decision_variable.subclass:
            return decision_variable.subclass(*args_, **kwargs_)
        else:
            return decision_variable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_domain(self): return self.domain
    def set_domain(self, domain): self.domain = domain
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.domain is not None or
            super(decision_variable, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='decision-variable', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='decision-variable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='decision-variable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='decision-variable'):
        super(decision_variable, self).exportAttributes(outfile, level, already_processed, namespace_, name_='decision-variable')
    def exportChildren(self, outfile, level, namespace_='', name_='decision-variable', fromsubclass_=False, pretty_print=True):
        super(decision_variable, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_format_string(quote_xml(self.type_), input_name='type'), namespace_, eol_))
        if self.domain is not None:
            self.domain.export(outfile, level, namespace_, name_='domain', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='decision-variable'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(decision_variable, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(decision_variable, self).exportLiteralChildren(outfile, level, name_)
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % quote_python(self.type_))
        if self.domain is not None:
            showIndent(outfile, level)
            outfile.write('domain=model_.domainType(\n')
            self.domain.exportLiteral(outfile, level, name_='domain')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(decision_variable, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'domain':
            obj_ = domainType.factory()
            obj_.build(child_)
            self.domain = obj_
            obj_.original_tagname_ = 'domain'
        super(decision_variable, self).buildChildren(child_, node, nodeName_, True)
# end class decision_variable


class state_variable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, domain=None):
        self.original_tagname_ = None
        self.id = id
        self.name = name
        self.domain = domain
    def factory(*args_, **kwargs_):
        if state_variable.subclass:
            return state_variable.subclass(*args_, **kwargs_)
        else:
            return state_variable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_domain(self): return self.domain
    def set_domain(self, domain): self.domain = domain
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.domain is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='state-variable', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='state-variable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='state-variable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='state-variable'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='state-variable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_string(quote_xml(self.id), input_name='id'), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name), input_name='name'), namespace_, eol_))
        if self.domain is not None:
            self.domain.export(outfile, level, namespace_, name_='domain', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='state-variable'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % quote_python(self.id))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name))
        if self.domain is not None:
            showIndent(outfile, level)
            outfile.write('domain=model_.variable_domain(\n')
            self.domain.exportLiteral(outfile, level, name_='domain')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id = id_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'domain':
            obj_ = variable_domain.factory()
            obj_.build(child_)
            self.domain = obj_
            obj_.original_tagname_ = 'domain'
# end class state_variable


class distribution(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, distribution_type=None, parameters=None):
        self.original_tagname_ = None
        self.distribution_type = distribution_type
        self.parameters = parameters
    def factory(*args_, **kwargs_):
        if distribution.subclass:
            return distribution.subclass(*args_, **kwargs_)
        else:
            return distribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_distribution_type(self): return self.distribution_type
    def set_distribution_type(self, distribution_type): self.distribution_type = distribution_type
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def hasContent_(self):
        if (
            self.distribution_type is not None or
            self.parameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='distribution', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='distribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='distribution', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='distribution'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='distribution', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.distribution_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdistribution-type>%s</%sdistribution-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.distribution_type), input_name='distribution-type'), namespace_, eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_, name_='parameters', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='distribution'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.distribution_type is not None:
            showIndent(outfile, level)
            outfile.write('distribution_type=%s,\n' % quote_python(self.distribution_type))
        if self.parameters is not None:
            showIndent(outfile, level)
            outfile.write('parameters=model_.parametersType(\n')
            self.parameters.exportLiteral(outfile, level, name_='parameters')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'distribution-type':
            distribution_type_ = child_.text
            distribution_type_ = self.gds_validate_string(distribution_type_, node, 'distribution_type')
            self.distribution_type = distribution_type_
        elif nodeName_ == 'parameters':
            obj_ = parametersType.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
# end class distribution


class duration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, bounded_duration=None, set_bounded_uncertain_duration=None, probabilistic_uncertain_duration=None, valueOf_=None):
        self.original_tagname_ = None
        self.bounded_duration = bounded_duration
        self.set_bounded_uncertain_duration = set_bounded_uncertain_duration
        self.probabilistic_uncertain_duration = probabilistic_uncertain_duration
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if duration.subclass:
            return duration.subclass(*args_, **kwargs_)
        else:
            return duration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bounded_duration(self): return self.bounded_duration
    def set_bounded_duration(self, bounded_duration): self.bounded_duration = bounded_duration
    def get_set_bounded_uncertain_duration(self): return self.set_bounded_uncertain_duration
    def set_set_bounded_uncertain_duration(self, set_bounded_uncertain_duration): self.set_bounded_uncertain_duration = set_bounded_uncertain_duration
    def get_probabilistic_uncertain_duration(self): return self.probabilistic_uncertain_duration
    def set_probabilistic_uncertain_duration(self, probabilistic_uncertain_duration): self.probabilistic_uncertain_duration = probabilistic_uncertain_duration
    def hasContent_(self):
        if (
            self.bounded_duration is not None or
            self.set_bounded_uncertain_duration is not None or
            self.probabilistic_uncertain_duration is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='duration', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='duration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='duration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='duration'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='duration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bounded_duration is not None:
            self.bounded_duration.export(outfile, level, namespace_, name_='bounded-duration', pretty_print=pretty_print)
        if self.set_bounded_uncertain_duration is not None:
            self.set_bounded_uncertain_duration.export(outfile, level, namespace_, name_='set-bounded-uncertain-duration', pretty_print=pretty_print)
        if self.probabilistic_uncertain_duration is not None:
            self.probabilistic_uncertain_duration.export(outfile, level, namespace_, name_='probabilistic-uncertain-duration', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='duration'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.bounded_duration is not None:
            showIndent(outfile, level)
            outfile.write('bounded_duration=model_.bounded_durationType(\n')
            self.bounded_duration.exportLiteral(outfile, level, name_='bounded_duration')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.set_bounded_uncertain_duration is not None:
            showIndent(outfile, level)
            outfile.write('set_bounded_uncertain_duration=model_.set_bounded_uncertain_durationType(\n')
            self.set_bounded_uncertain_duration.exportLiteral(outfile, level, name_='set_bounded_uncertain_duration')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.probabilistic_uncertain_duration is not None:
            showIndent(outfile, level)
            outfile.write('probabilistic_uncertain_duration=model_.distribution(\n')
            self.probabilistic_uncertain_duration.exportLiteral(outfile, level, name_='probabilistic_uncertain_duration')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bounded-duration':
            obj_ = bounded_durationType.factory()
            obj_.build(child_)
            self.bounded_duration = obj_
            obj_.original_tagname_ = 'bounded-duration'
        elif nodeName_ == 'set-bounded-uncertain-duration':
            obj_ = set_bounded_uncertain_durationType.factory()
            obj_.build(child_)
            self.set_bounded_uncertain_duration = obj_
            obj_.original_tagname_ = 'set-bounded-uncertain-duration'
        elif nodeName_ == 'probabilistic-uncertain-duration':
            obj_ = distribution.factory()
            obj_.build(child_)
            self.probabilistic_uncertain_duration = obj_
            obj_.original_tagname_ = 'probabilistic-uncertain-duration'
# end class duration


class wff_value(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, constant=None, state_variable=None):
        self.original_tagname_ = None
        self.constant = constant
        self.state_variable = state_variable
    def factory(*args_, **kwargs_):
        if wff_value.subclass:
            return wff_value.subclass(*args_, **kwargs_)
        else:
            return wff_value(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_constant(self): return self.constant
    def set_constant(self, constant): self.constant = constant
    def get_state_variable(self): return self.state_variable
    def set_state_variable(self, state_variable): self.state_variable = state_variable
    def hasContent_(self):
        if (
            self.constant is not None or
            self.state_variable is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='wff-value', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='wff-value')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='wff-value', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='wff-value'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='wff-value', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.constant is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconstant>%s</%sconstant>%s' % (namespace_, self.gds_format_string(quote_xml(self.constant), input_name='constant'), namespace_, eol_))
        if self.state_variable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstate-variable>%s</%sstate-variable>%s' % (namespace_, self.gds_format_string(quote_xml(self.state_variable), input_name='state-variable'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='wff-value'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.constant is not None:
            showIndent(outfile, level)
            outfile.write('constant=%s,\n' % quote_python(self.constant))
        if self.state_variable is not None:
            showIndent(outfile, level)
            outfile.write('state_variable=%s,\n' % quote_python(self.state_variable))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'constant':
            constant_ = child_.text
            constant_ = self.gds_validate_string(constant_, node, 'constant')
            self.constant = constant_
        elif nodeName_ == 'state-variable':
            state_variable_ = child_.text
            state_variable_ = self.gds_validate_string(state_variable_, node, 'state_variable')
            self.state_variable = state_variable_
# end class wff_value


class wff_boolean_expression(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, condition=None, value=None):
        self.original_tagname_ = None
        self.condition = condition
        if value is None:
            self.value = []
        else:
            self.value = value
    def factory(*args_, **kwargs_):
        if wff_boolean_expression.subclass:
            return wff_boolean_expression.subclass(*args_, **kwargs_)
        else:
            return wff_boolean_expression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value_at(self, index, value): self.value.insert(index, value)
    def replace_value_at(self, index, value): self.value[index] = value
    def hasContent_(self):
        if (
            self.condition is not None or
            self.value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='wff-boolean-expression', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='wff-boolean-expression')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='wff-boolean-expression', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='wff-boolean-expression'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='wff-boolean-expression', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.condition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scondition>%s</%scondition>%s' % (namespace_, self.gds_format_string(quote_xml(self.condition), input_name='condition'), namespace_, eol_))
        for value_ in self.value:
            value_.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='wff-boolean-expression'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.condition is not None:
            showIndent(outfile, level)
            outfile.write('condition=%s,\n' % quote_python(self.condition))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('model_.wff_value(\n')
            value_.exportLiteral(outfile, level, name_='wff-value')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'condition':
            condition_ = child_.text
            condition_ = self.gds_validate_string(condition_, node, 'condition')
            self.condition = condition_
        elif nodeName_ == 'value':
            obj_ = wff_value.factory()
            obj_.build(child_)
            self.value.append(obj_)
            obj_.original_tagname_ = 'value'
# end class wff_boolean_expression


class wff_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, wff=None):
        self.original_tagname_ = None
        if wff is None:
            self.wff = []
        else:
            self.wff = wff
    def factory(*args_, **kwargs_):
        if wff_list.subclass:
            return wff_list.subclass(*args_, **kwargs_)
        else:
            return wff_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_wff(self): return self.wff
    def set_wff(self, wff): self.wff = wff
    def add_wff(self, value): self.wff.append(value)
    def insert_wff_at(self, index, value): self.wff.insert(index, value)
    def replace_wff_at(self, index, value): self.wff[index] = value
    def hasContent_(self):
        if (
            self.wff
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='wff-list', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='wff-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='wff-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='wff-list'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='wff-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for wff_ in self.wff:
            wff_.export(outfile, level, namespace_, name_='wff', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='wff-list'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('wff=[\n')
        level += 1
        for wff_ in self.wff:
            showIndent(outfile, level)
            outfile.write('model_.wff(\n')
            wff_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'wff':
            obj_ = wff.factory()
            obj_.build(child_)
            self.wff.append(obj_)
            obj_.original_tagname_ = 'wff'
# end class wff_list


class wff(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, boolean_constant=None, boolean_expression=None, and_=None, or_=None, not_=None):
        self.original_tagname_ = None
        self.boolean_constant = boolean_constant
        self.boolean_expression = boolean_expression
        self.and_ = and_
        self.or_ = or_
        self.not_ = not_
    def factory(*args_, **kwargs_):
        if wff.subclass:
            return wff.subclass(*args_, **kwargs_)
        else:
            return wff(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_boolean_constant(self): return self.boolean_constant
    def set_boolean_constant(self, boolean_constant): self.boolean_constant = boolean_constant
    def get_boolean_expression(self): return self.boolean_expression
    def set_boolean_expression(self, boolean_expression): self.boolean_expression = boolean_expression
    def get_and(self): return self.and_
    def set_and(self, and_): self.and_ = and_
    def get_or(self): return self.or_
    def set_or(self, or_): self.or_ = or_
    def get_not(self): return self.not_
    def set_not(self, not_): self.not_ = not_
    def hasContent_(self):
        if (
            self.boolean_constant is not None or
            self.boolean_expression is not None or
            self.and_ is not None or
            self.or_ is not None or
            self.not_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='wff', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='wff')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='wff', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='wff'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='wff', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.boolean_constant is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sboolean-constant>%s</%sboolean-constant>%s' % (namespace_, self.gds_format_boolean(self.boolean_constant, input_name='boolean-constant'), namespace_, eol_))
        if self.boolean_expression is not None:
            self.boolean_expression.export(outfile, level, namespace_, name_='boolean-expression', pretty_print=pretty_print)
        if self.and_ is not None:
            self.and_.export(outfile, level, namespace_, name_='and', pretty_print=pretty_print)
        if self.or_ is not None:
            self.or_.export(outfile, level, namespace_, name_='or', pretty_print=pretty_print)
        if self.not_ is not None:
            self.not_.export(outfile, level, namespace_, name_='not', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='wff'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.boolean_constant is not None:
            showIndent(outfile, level)
            outfile.write('boolean_constant=%s,\n' % self.boolean_constant)
        if self.boolean_expression is not None:
            showIndent(outfile, level)
            outfile.write('boolean_expression=model_.wff_boolean_expression(\n')
            self.boolean_expression.exportLiteral(outfile, level, name_='boolean_expression')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.and_ is not None:
            showIndent(outfile, level)
            outfile.write('and_=model_.wff_list(\n')
            self.and_.exportLiteral(outfile, level, name_='and')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.or_ is not None:
            showIndent(outfile, level)
            outfile.write('or_=model_.wff_list(\n')
            self.or_.exportLiteral(outfile, level, name_='or')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.not_ is not None:
            showIndent(outfile, level)
            outfile.write('not_=model_.notType1(\n')
            self.not_.exportLiteral(outfile, level, name_='not')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'boolean-constant':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'boolean_constant')
            self.boolean_constant = ival_
        elif nodeName_ == 'boolean-expression':
            obj_ = wff_boolean_expression.factory()
            obj_.build(child_)
            self.boolean_expression = obj_
            obj_.original_tagname_ = 'boolean-expression'
        elif nodeName_ == 'and':
            obj_ = wff_list.factory()
            obj_.build(child_)
            self.and_ = obj_
            obj_.original_tagname_ = 'and'
        elif nodeName_ == 'or':
            obj_ = wff_list.factory()
            obj_.build(child_)
            self.or_ = obj_
            obj_.original_tagname_ = 'or'
        elif nodeName_ == 'not':
            obj_ = notType1.factory()
            obj_.build(child_)
            self.not_ = obj_
            obj_.original_tagname_ = 'not'
# end class wff


class state_constraint(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, wff=None):
        self.original_tagname_ = None
        self.wff = wff
    def factory(*args_, **kwargs_):
        if state_constraint.subclass:
            return state_constraint.subclass(*args_, **kwargs_)
        else:
            return state_constraint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_wff(self): return self.wff
    def set_wff(self, wff): self.wff = wff
    def hasContent_(self):
        if (
            self.wff is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='state-constraint', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='state-constraint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='state-constraint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='state-constraint'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='state-constraint', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.wff is not None:
            self.wff.export(outfile, level, namespace_, name_='wff', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='state-constraint'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.wff is not None:
            showIndent(outfile, level)
            outfile.write('wff=model_.wff(\n')
            self.wff.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'wff':
            obj_ = wff.factory()
            obj_.build(child_)
            self.wff = obj_
            obj_.original_tagname_ = 'wff'
# end class state_constraint


class event(dispatchable_guarded_tn_member):
    subclass = None
    superclass = dispatchable_guarded_tn_member
    def __init__(self, id=None, name=None, guard=None, dispatch=None):
        self.original_tagname_ = None
        super(event, self).__init__(id, name, guard, dispatch, )
    def factory(*args_, **kwargs_):
        if event.subclass:
            return event.subclass(*args_, **kwargs_)
        else:
            return event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(event, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='event', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='event')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='event', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='event'):
        super(event, self).exportAttributes(outfile, level, already_processed, namespace_, name_='event')
    def exportChildren(self, outfile, level, namespace_='', name_='event', fromsubclass_=False, pretty_print=True):
        super(event, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='event'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(event, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(event, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(event, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(event, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class event


class temporal_constraint(guarded_tn_member):
    subclass = None
    superclass = guarded_tn_member
    def __init__(self, id=None, name=None, guard=None, to_event=None, from_event=None, duration=None, extensiontype_=None):
        self.original_tagname_ = None
        super(temporal_constraint, self).__init__(id, name, guard, extensiontype_, )
        self.to_event = to_event
        self.from_event = from_event
        self.duration = duration
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if temporal_constraint.subclass:
            return temporal_constraint.subclass(*args_, **kwargs_)
        else:
            return temporal_constraint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_to_event(self): return self.to_event
    def set_to_event(self, to_event): self.to_event = to_event
    def get_from_event(self): return self.from_event
    def set_from_event(self, from_event): self.from_event = from_event
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.to_event is not None or
            self.from_event is not None or
            self.duration is not None or
            super(temporal_constraint, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='temporal-constraint', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='temporal-constraint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='temporal-constraint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='temporal-constraint'):
        super(temporal_constraint, self).exportAttributes(outfile, level, already_processed, namespace_, name_='temporal-constraint')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='temporal-constraint', fromsubclass_=False, pretty_print=True):
        super(temporal_constraint, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.to_event is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sto-event>%s</%sto-event>%s' % (namespace_, self.gds_format_string(quote_xml(self.to_event), input_name='to-event'), namespace_, eol_))
        if self.from_event is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfrom-event>%s</%sfrom-event>%s' % (namespace_, self.gds_format_string(quote_xml(self.from_event), input_name='from-event'), namespace_, eol_))
        if self.duration is not None:
            self.duration.export(outfile, level, namespace_, name_='duration', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='temporal-constraint'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(temporal_constraint, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(temporal_constraint, self).exportLiteralChildren(outfile, level, name_)
        if self.to_event is not None:
            showIndent(outfile, level)
            outfile.write('to_event=%s,\n' % quote_python(self.to_event))
        if self.from_event is not None:
            showIndent(outfile, level)
            outfile.write('from_event=%s,\n' % quote_python(self.from_event))
        if self.duration is not None:
            showIndent(outfile, level)
            outfile.write('duration=model_.duration(\n')
            self.duration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(temporal_constraint, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'to-event':
            to_event_ = child_.text
            to_event_ = self.gds_validate_string(to_event_, node, 'to_event')
            self.to_event = to_event_
        elif nodeName_ == 'from-event':
            from_event_ = child_.text
            from_event_ = self.gds_validate_string(from_event_, node, 'from_event')
            self.from_event = from_event_
        elif nodeName_ == 'duration':
            obj_ = duration.factory()
            obj_.build(child_)
            self.duration = obj_
            obj_.original_tagname_ = 'duration'
        super(temporal_constraint, self).buildChildren(child_, node, nodeName_, True)
# end class temporal_constraint


class episode(temporal_constraint):
    subclass = None
    superclass = temporal_constraint
    def __init__(self, id=None, name=None, guard=None, to_event=None, from_event=None, duration=None, dispatch=None, macro_tpn_id=None, state_constraint=None):
        self.original_tagname_ = None
        super(episode, self).__init__(id, name, guard, to_event, from_event, duration, )
        self.dispatch = dispatch
        self.macro_tpn_id = macro_tpn_id
        self.state_constraint = state_constraint
    def factory(*args_, **kwargs_):
        if episode.subclass:
            return episode.subclass(*args_, **kwargs_)
        else:
            return episode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dispatch(self): return self.dispatch
    def set_dispatch(self, dispatch): self.dispatch = dispatch
    def get_macro_tpn_id(self): return self.macro_tpn_id
    def set_macro_tpn_id(self, macro_tpn_id): self.macro_tpn_id = macro_tpn_id
    def get_state_constraint(self): return self.state_constraint
    def set_state_constraint(self, state_constraint): self.state_constraint = state_constraint
    def hasContent_(self):
        if (
            self.dispatch is not None or
            self.macro_tpn_id is not None or
            self.state_constraint is not None or
            super(episode, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='episode', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='episode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='episode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='episode'):
        super(episode, self).exportAttributes(outfile, level, already_processed, namespace_, name_='episode')
    def exportChildren(self, outfile, level, namespace_='', name_='episode', fromsubclass_=False, pretty_print=True):
        super(episode, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dispatch is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdispatch>%s</%sdispatch>%s' % (namespace_, self.gds_format_string(quote_xml(self.dispatch), input_name='dispatch'), namespace_, eol_))
        if self.macro_tpn_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smacro-tpn-id>%s</%smacro-tpn-id>%s' % (namespace_, self.gds_format_string(quote_xml(self.macro_tpn_id), input_name='macro-tpn-id'), namespace_, eol_))
        if self.state_constraint is not None:
            self.state_constraint.export(outfile, level, namespace_, name_='state-constraint', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='episode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(episode, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(episode, self).exportLiteralChildren(outfile, level, name_)
        if self.dispatch is not None:
            showIndent(outfile, level)
            outfile.write('dispatch=%s,\n' % quote_python(self.dispatch))
        if self.macro_tpn_id is not None:
            showIndent(outfile, level)
            outfile.write('macro_tpn_id=%s,\n' % quote_python(self.macro_tpn_id))
        if self.state_constraint is not None:
            showIndent(outfile, level)
            outfile.write('state_constraint=model_.state_constraint(\n')
            self.state_constraint.exportLiteral(outfile, level, name_='state_constraint')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(episode, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dispatch':
            dispatch_ = child_.text
            dispatch_ = self.gds_validate_string(dispatch_, node, 'dispatch')
            self.dispatch = dispatch_
        elif nodeName_ == 'macro-tpn-id':
            macro_tpn_id_ = child_.text
            macro_tpn_id_ = self.gds_validate_string(macro_tpn_id_, node, 'macro_tpn_id')
            self.macro_tpn_id = macro_tpn_id_
        elif nodeName_ == 'state-constraint':
            obj_ = state_constraint.factory()
            obj_.build(child_)
            self.state_constraint = obj_
            obj_.original_tagname_ = 'state-constraint'
        super(episode, self).buildChildren(child_, node, nodeName_, True)
# end class episode


class chance_constraint(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, constraints=None, probability=None):
        self.original_tagname_ = None
        self.id = id
        self.name = name
        self.constraints = constraints
        self.probability = probability
    def factory(*args_, **kwargs_):
        if chance_constraint.subclass:
            return chance_constraint.subclass(*args_, **kwargs_)
        else:
            return chance_constraint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_constraints(self): return self.constraints
    def set_constraints(self, constraints): self.constraints = constraints
    def get_probability(self): return self.probability
    def set_probability(self, probability): self.probability = probability
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.constraints is not None or
            self.probability is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='chance-constraint', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='chance-constraint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='chance-constraint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='chance-constraint'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='chance-constraint', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_string(quote_xml(self.id), input_name='id'), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name), input_name='name'), namespace_, eol_))
        if self.constraints is not None:
            self.constraints.export(outfile, level, namespace_, name_='constraints', pretty_print=pretty_print)
        if self.probability is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprobability>%s</%sprobability>%s' % (namespace_, self.gds_format_float(self.probability, input_name='probability'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='chance-constraint'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % quote_python(self.id))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name))
        if self.constraints is not None:
            showIndent(outfile, level)
            outfile.write('constraints=%s,\n' % quote_python(self.constraints))
        if self.probability is not None:
            showIndent(outfile, level)
            outfile.write('probability=%f,\n' % self.probability)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id = id_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'constraints':
            obj_ = xs_IDREFS.factory()
            obj_.build(child_)
            self.constraints = obj_
            obj_.original_tagname_ = 'constraints'
        elif nodeName_ == 'probability':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'probability')
            self.probability = fval_
# end class chance_constraint


class state_variable_assignment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, state_variable=None, value=None):
        self.original_tagname_ = None
        self.state_variable = state_variable
        self.value = value
    def factory(*args_, **kwargs_):
        if state_variable_assignment.subclass:
            return state_variable_assignment.subclass(*args_, **kwargs_)
        else:
            return state_variable_assignment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_state_variable(self): return self.state_variable
    def set_state_variable(self, state_variable): self.state_variable = state_variable
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.state_variable is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='state-variable-assignment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='state-variable-assignment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='state-variable-assignment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='state-variable-assignment'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='state-variable-assignment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.state_variable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstate-variable>%s</%sstate-variable>%s' % (namespace_, self.gds_format_string(quote_xml(self.state_variable), input_name='state-variable'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value), input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='state-variable-assignment'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.state_variable is not None:
            showIndent(outfile, level)
            outfile.write('state_variable=%s,\n' % quote_python(self.state_variable))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'state-variable':
            state_variable_ = child_.text
            state_variable_ = self.gds_validate_string(state_variable_, node, 'state_variable')
            self.state_variable = state_variable_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class state_variable_assignment


class state(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, assignment=None):
        self.original_tagname_ = None
        if assignment is None:
            self.assignment = []
        else:
            self.assignment = assignment
    def factory(*args_, **kwargs_):
        if state.subclass:
            return state.subclass(*args_, **kwargs_)
        else:
            return state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_assignment(self): return self.assignment
    def set_assignment(self, assignment): self.assignment = assignment
    def add_assignment(self, value): self.assignment.append(value)
    def insert_assignment_at(self, index, value): self.assignment.insert(index, value)
    def replace_assignment_at(self, index, value): self.assignment[index] = value
    def hasContent_(self):
        if (
            self.assignment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='state', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='state')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='state', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='state'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='state', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for assignment_ in self.assignment:
            assignment_.export(outfile, level, namespace_, name_='assignment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='state'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('assignment=[\n')
        level += 1
        for assignment_ in self.assignment:
            showIndent(outfile, level)
            outfile.write('model_.state_variable_assignment(\n')
            assignment_.exportLiteral(outfile, level, name_='state-variable-assignment')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'assignment':
            obj_ = state_variable_assignment.factory()
            obj_.build(child_)
            self.assignment.append(obj_)
            obj_.original_tagname_ = 'assignment'
# end class state


class tpn(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, features=None, start_event=None, end_event=None, events=None, temporal_constraints=None, episodes=None, chance_constraints=None, decision_variables=None, state_variables=None, initial_state=None):
        self.original_tagname_ = None
        self.id = id
        self.name = name
        self.features = features
        self.start_event = start_event
        self.end_event = end_event
        self.events = events
        self.temporal_constraints = temporal_constraints
        self.episodes = episodes
        self.chance_constraints = chance_constraints
        self.decision_variables = decision_variables
        self.state_variables = state_variables
        self.initial_state = initial_state
    def factory(*args_, **kwargs_):
        if tpn.subclass:
            return tpn.subclass(*args_, **kwargs_)
        else:
            return tpn(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_features(self): return self.features
    def set_features(self, features): self.features = features
    def get_start_event(self): return self.start_event
    def set_start_event(self, start_event): self.start_event = start_event
    def get_end_event(self): return self.end_event
    def set_end_event(self, end_event): self.end_event = end_event
    def get_events(self): return self.events
    def set_events(self, events): self.events = events
    def get_temporal_constraints(self): return self.temporal_constraints
    def set_temporal_constraints(self, temporal_constraints): self.temporal_constraints = temporal_constraints
    def get_episodes(self): return self.episodes
    def set_episodes(self, episodes): self.episodes = episodes
    def get_chance_constraints(self): return self.chance_constraints
    def set_chance_constraints(self, chance_constraints): self.chance_constraints = chance_constraints
    def get_decision_variables(self): return self.decision_variables
    def set_decision_variables(self, decision_variables): self.decision_variables = decision_variables
    def get_state_variables(self): return self.state_variables
    def set_state_variables(self, state_variables): self.state_variables = state_variables
    def get_initial_state(self): return self.initial_state
    def set_initial_state(self, initial_state): self.initial_state = initial_state
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.features is not None or
            self.start_event is not None or
            self.end_event is not None or
            self.events is not None or
            self.temporal_constraints is not None or
            self.episodes is not None or
            self.chance_constraints is not None or
            self.decision_variables is not None or
            self.state_variables is not None or
            self.initial_state is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpn', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpn')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpn', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpn'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpn', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_string(quote_xml(self.id), input_name='id'), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name), input_name='name'), namespace_, eol_))
        if self.features is not None:
            self.features.export(outfile, level, namespace_, name_='features', pretty_print=pretty_print)
        if self.start_event is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstart-event>%s</%sstart-event>%s' % (namespace_, self.gds_format_string(quote_xml(self.start_event), input_name='start-event'), namespace_, eol_))
        if self.end_event is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%send-event>%s</%send-event>%s' % (namespace_, self.gds_format_string(quote_xml(self.end_event), input_name='end-event'), namespace_, eol_))
        if self.events is not None:
            self.events.export(outfile, level, namespace_, name_='events', pretty_print=pretty_print)
        if self.temporal_constraints is not None:
            self.temporal_constraints.export(outfile, level, namespace_, name_='temporal-constraints', pretty_print=pretty_print)
        if self.episodes is not None:
            self.episodes.export(outfile, level, namespace_, name_='episodes', pretty_print=pretty_print)
        if self.chance_constraints is not None:
            self.chance_constraints.export(outfile, level, namespace_, name_='chance-constraints', pretty_print=pretty_print)
        if self.decision_variables is not None:
            self.decision_variables.export(outfile, level, namespace_, name_='decision-variables', pretty_print=pretty_print)
        if self.state_variables is not None:
            self.state_variables.export(outfile, level, namespace_, name_='state-variables', pretty_print=pretty_print)
        if self.initial_state is not None:
            self.initial_state.export(outfile, level, namespace_, name_='initial-state', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='tpn'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % quote_python(self.id))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name))
        if self.features is not None:
            showIndent(outfile, level)
            outfile.write('features=model_.featuresType(\n')
            self.features.exportLiteral(outfile, level, name_='features')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.start_event is not None:
            showIndent(outfile, level)
            outfile.write('start_event=%s,\n' % quote_python(self.start_event))
        if self.end_event is not None:
            showIndent(outfile, level)
            outfile.write('end_event=%s,\n' % quote_python(self.end_event))
        if self.events is not None:
            showIndent(outfile, level)
            outfile.write('events=model_.eventsType(\n')
            self.events.exportLiteral(outfile, level, name_='events')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.temporal_constraints is not None:
            showIndent(outfile, level)
            outfile.write('temporal_constraints=model_.temporal_constraintsType(\n')
            self.temporal_constraints.exportLiteral(outfile, level, name_='temporal_constraints')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.episodes is not None:
            showIndent(outfile, level)
            outfile.write('episodes=model_.episodesType(\n')
            self.episodes.exportLiteral(outfile, level, name_='episodes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.chance_constraints is not None:
            showIndent(outfile, level)
            outfile.write('chance_constraints=model_.chance_constraintsType(\n')
            self.chance_constraints.exportLiteral(outfile, level, name_='chance_constraints')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.decision_variables is not None:
            showIndent(outfile, level)
            outfile.write('decision_variables=model_.decision_variablesType(\n')
            self.decision_variables.exportLiteral(outfile, level, name_='decision_variables')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.state_variables is not None:
            showIndent(outfile, level)
            outfile.write('state_variables=model_.state_variablesType(\n')
            self.state_variables.exportLiteral(outfile, level, name_='state_variables')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.initial_state is not None:
            showIndent(outfile, level)
            outfile.write('initial_state=model_.state(\n')
            self.initial_state.exportLiteral(outfile, level, name_='initial_state')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id = id_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'features':
            obj_ = featuresType.factory()
            obj_.build(child_)
            self.features = obj_
            obj_.original_tagname_ = 'features'
        elif nodeName_ == 'start-event':
            start_event_ = child_.text
            start_event_ = self.gds_validate_string(start_event_, node, 'start_event')
            self.start_event = start_event_
        elif nodeName_ == 'end-event':
            end_event_ = child_.text
            end_event_ = self.gds_validate_string(end_event_, node, 'end_event')
            self.end_event = end_event_
        elif nodeName_ == 'events':
            obj_ = eventsType.factory()
            obj_.build(child_)
            self.events = obj_
            obj_.original_tagname_ = 'events'
        elif nodeName_ == 'temporal-constraints':
            obj_ = temporal_constraintsType.factory()
            obj_.build(child_)
            self.temporal_constraints = obj_
            obj_.original_tagname_ = 'temporal-constraints'
        elif nodeName_ == 'episodes':
            obj_ = episodesType.factory()
            obj_.build(child_)
            self.episodes = obj_
            obj_.original_tagname_ = 'episodes'
        elif nodeName_ == 'chance-constraints':
            obj_ = chance_constraintsType.factory()
            obj_.build(child_)
            self.chance_constraints = obj_
            obj_.original_tagname_ = 'chance-constraints'
        elif nodeName_ == 'decision-variables':
            obj_ = decision_variablesType.factory()
            obj_.build(child_)
            self.decision_variables = obj_
            obj_.original_tagname_ = 'decision-variables'
        elif nodeName_ == 'state-variables':
            obj_ = state_variablesType.factory()
            obj_.build(child_)
            self.state_variables = obj_
            obj_.original_tagname_ = 'state-variables'
        elif nodeName_ == 'initial-state':
            obj_ = state.factory()
            obj_.build(child_)
            self.initial_state = obj_
            obj_.original_tagname_ = 'initial-state'
# end class tpn


class tpns(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tpn=None):
        self.original_tagname_ = None
        if tpn is None:
            self.tpn = []
        else:
            self.tpn = tpn
    def factory(*args_, **kwargs_):
        if tpns.subclass:
            return tpns.subclass(*args_, **kwargs_)
        else:
            return tpns(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpn(self): return self.tpn
    def set_tpn(self, tpn): self.tpn = tpn
    def add_tpn(self, value): self.tpn.append(value)
    def insert_tpn_at(self, index, value): self.tpn.insert(index, value)
    def replace_tpn_at(self, index, value): self.tpn[index] = value
    def hasContent_(self):
        if (
            self.tpn
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpns', namespacedef_='xmlns="http://mers.csail.mit.edu/tpn"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpns')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpns', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpns'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpns', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tpn_ in self.tpn:
            tpn_.export(outfile, level, namespace_, name_='tpn', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='tpns'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('tpn=[\n')
        level += 1
        for tpn_ in self.tpn:
            showIndent(outfile, level)
            outfile.write('model_.tpn(\n')
            tpn_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpn':
            obj_ = tpn.factory()
            obj_.build(child_)
            self.tpn.append(obj_)
            obj_.original_tagname_ = 'tpn'
# end class tpns


class xs_IDREF(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None):
        self.original_tagname_ = None
        self.id = id
    def factory(*args_, **kwargs_):
        if xs_IDREF.subclass:
            return xs_IDREF.subclass(*args_, **kwargs_)
        else:
            return xs_IDREF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xs_IDREF', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xs_IDREF')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xs_IDREF', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xs_IDREF'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xs_IDREF', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_string(quote_xml(self.id), input_name='id'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='xs_IDREF'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % quote_python(self.id))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id = id_
# end class xs_IDREF


class xs_IDREFS(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None):
        self.original_tagname_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
    def factory(*args_, **kwargs_):
        if xs_IDREFS.subclass:
            return xs_IDREFS.subclass(*args_, **kwargs_)
        else:
            return xs_IDREFS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def add_id(self, value): self.id.append(value)
    def insert_id_at(self, index, value): self.id.insert(index, value)
    def replace_id_at(self, index, value): self.id[index] = value
    def hasContent_(self):
        if (
            self.id
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xs_IDREFS', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xs_IDREFS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xs_IDREFS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xs_IDREFS'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xs_IDREFS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for id_ in self.id:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_string(quote_xml(id_), input_name='id'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='xs_IDREFS'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('id=[\n')
        level += 1
        for id_ in self.id:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(id_))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id.append(id_)
# end class xs_IDREFS


class notType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, guard=None):
        self.original_tagname_ = None
        self.guard = guard
    def factory(*args_, **kwargs_):
        if notType.subclass:
            return notType.subclass(*args_, **kwargs_)
        else:
            return notType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_guard(self): return self.guard
    def set_guard(self, guard): self.guard = guard
    def hasContent_(self):
        if (
            self.guard is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='notType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='notType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='notType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='notType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='notType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.guard is not None:
            self.guard.export(outfile, level, namespace_, name_='guard', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='notType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.guard is not None:
            showIndent(outfile, level)
            outfile.write('guard=model_.guard(\n')
            self.guard.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'guard':
            obj_ = guard.factory()
            obj_.build(child_)
            self.guard = obj_
            obj_.original_tagname_ = 'guard'
# end class notType


class domainType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, domainval=None):
        self.original_tagname_ = None
        if domainval is None:
            self.domainval = []
        else:
            self.domainval = domainval
    def factory(*args_, **kwargs_):
        if domainType.subclass:
            return domainType.subclass(*args_, **kwargs_)
        else:
            return domainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_domainval(self): return self.domainval
    def set_domainval(self, domainval): self.domainval = domainval
    def add_domainval(self, value): self.domainval.append(value)
    def insert_domainval_at(self, index, value): self.domainval.insert(index, value)
    def replace_domainval_at(self, index, value): self.domainval[index] = value
    def hasContent_(self):
        if (
            self.domainval
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='domainType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='domainType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='domainType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='domainType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='domainType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for domainval_ in self.domainval:
            domainval_.export(outfile, level, namespace_, name_='domainval', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='domainType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('domainval=[\n')
        level += 1
        for domainval_ in self.domainval:
            showIndent(outfile, level)
            outfile.write('model_.domainvalType(\n')
            domainval_.exportLiteral(outfile, level, name_='domainvalType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'domainval':
            obj_ = domainvalType.factory()
            obj_.build(child_)
            self.domainval.append(obj_)
            obj_.original_tagname_ = 'domainval'
# end class domainType


class domainvalType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, utility=None, probability=None):
        self.original_tagname_ = None
        self.value = value
        self.utility = utility
        self.probability = probability
    def factory(*args_, **kwargs_):
        if domainvalType.subclass:
            return domainvalType.subclass(*args_, **kwargs_)
        else:
            return domainvalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_utility(self): return self.utility
    def set_utility(self, utility): self.utility = utility
    def get_probability(self): return self.probability
    def set_probability(self, probability): self.probability = probability
    def hasContent_(self):
        if (
            self.value is not None or
            self.utility is not None or
            self.probability is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='domainvalType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='domainvalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='domainvalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='domainvalType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='domainvalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value), input_name='value'), namespace_, eol_))
        if self.utility is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sutility>%s</%sutility>%s' % (namespace_, self.gds_format_double(self.utility, input_name='utility'), namespace_, eol_))
        if self.probability is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprobability>%s</%sprobability>%s' % (namespace_, self.gds_format_double(self.probability, input_name='probability'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='domainvalType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value))
        if self.utility is not None:
            showIndent(outfile, level)
            outfile.write('utility=%e,\n' % self.utility)
        if self.probability is not None:
            showIndent(outfile, level)
            outfile.write('probability=%e,\n' % self.probability)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'utility':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'utility')
            self.utility = fval_
        elif nodeName_ == 'probability':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'probability')
            self.probability = fval_
# end class domainvalType


class parametersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, parameter=None):
        self.original_tagname_ = None
        if parameter is None:
            self.parameter = []
        else:
            self.parameter = parameter
    def factory(*args_, **kwargs_):
        if parametersType.subclass:
            return parametersType.subclass(*args_, **kwargs_)
        else:
            return parametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_parameter(self): return self.parameter
    def set_parameter(self, parameter): self.parameter = parameter
    def add_parameter(self, value): self.parameter.append(value)
    def insert_parameter_at(self, index, value): self.parameter.insert(index, value)
    def replace_parameter_at(self, index, value): self.parameter[index] = value
    def hasContent_(self):
        if (
            self.parameter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='parametersType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='parametersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='parametersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='parametersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='parametersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for parameter_ in self.parameter:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sparameter>%s</%sparameter>%s' % (namespace_, self.gds_format_float(parameter_, input_name='parameter'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='parametersType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('parameter=[\n')
        level += 1
        for parameter_ in self.parameter:
            showIndent(outfile, level)
            outfile.write('%f,\n' % parameter_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parameter':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'parameter')
            self.parameter.append(fval_)
# end class parametersType


class bounded_durationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lower_bound=None, upper_bound=None):
        self.original_tagname_ = None
        self.lower_bound = lower_bound
        self.upper_bound = upper_bound
    def factory(*args_, **kwargs_):
        if bounded_durationType.subclass:
            return bounded_durationType.subclass(*args_, **kwargs_)
        else:
            return bounded_durationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lower_bound(self): return self.lower_bound
    def set_lower_bound(self, lower_bound): self.lower_bound = lower_bound
    def get_upper_bound(self): return self.upper_bound
    def set_upper_bound(self, upper_bound): self.upper_bound = upper_bound
    def hasContent_(self):
        if (
            self.lower_bound is not None or
            self.upper_bound is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='bounded-durationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bounded-durationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='bounded-durationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='bounded-durationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='bounded-durationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lower_bound is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slower-bound>%s</%slower-bound>%s' % (namespace_, self.gds_format_double(self.lower_bound, input_name='lower-bound'), namespace_, eol_))
        if self.upper_bound is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%supper-bound>%s</%supper-bound>%s' % (namespace_, self.gds_format_double(self.upper_bound, input_name='upper-bound'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='bounded-durationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.lower_bound is not None:
            showIndent(outfile, level)
            outfile.write('lower_bound=%e,\n' % self.lower_bound)
        if self.upper_bound is not None:
            showIndent(outfile, level)
            outfile.write('upper_bound=%e,\n' % self.upper_bound)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lower-bound':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'lower_bound')
            self.lower_bound = fval_
        elif nodeName_ == 'upper-bound':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'upper_bound')
            self.upper_bound = fval_
# end class bounded_durationType


class set_bounded_uncertain_durationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lower_bound=None, upper_bound=None):
        self.original_tagname_ = None
        self.lower_bound = lower_bound
        self.upper_bound = upper_bound
    def factory(*args_, **kwargs_):
        if set_bounded_uncertain_durationType.subclass:
            return set_bounded_uncertain_durationType.subclass(*args_, **kwargs_)
        else:
            return set_bounded_uncertain_durationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lower_bound(self): return self.lower_bound
    def set_lower_bound(self, lower_bound): self.lower_bound = lower_bound
    def get_upper_bound(self): return self.upper_bound
    def set_upper_bound(self, upper_bound): self.upper_bound = upper_bound
    def hasContent_(self):
        if (
            self.lower_bound is not None or
            self.upper_bound is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='set-bounded-uncertain-durationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='set-bounded-uncertain-durationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='set-bounded-uncertain-durationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='set-bounded-uncertain-durationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='set-bounded-uncertain-durationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lower_bound is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slower-bound>%s</%slower-bound>%s' % (namespace_, self.gds_format_double(self.lower_bound, input_name='lower-bound'), namespace_, eol_))
        if self.upper_bound is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%supper-bound>%s</%supper-bound>%s' % (namespace_, self.gds_format_double(self.upper_bound, input_name='upper-bound'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='set-bounded-uncertain-durationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.lower_bound is not None:
            showIndent(outfile, level)
            outfile.write('lower_bound=%e,\n' % self.lower_bound)
        if self.upper_bound is not None:
            showIndent(outfile, level)
            outfile.write('upper_bound=%e,\n' % self.upper_bound)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lower-bound':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'lower_bound')
            self.lower_bound = fval_
        elif nodeName_ == 'upper-bound':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'upper_bound')
            self.upper_bound = fval_
# end class set_bounded_uncertain_durationType


class notType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, wff=None):
        self.original_tagname_ = None
        self.wff = wff
    def factory(*args_, **kwargs_):
        if notType1.subclass:
            return notType1.subclass(*args_, **kwargs_)
        else:
            return notType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_wff(self): return self.wff
    def set_wff(self, wff): self.wff = wff
    def hasContent_(self):
        if (
            self.wff is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='notType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='notType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='notType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='notType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='notType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.wff is not None:
            self.wff.export(outfile, level, namespace_, name_='wff', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='notType1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.wff is not None:
            showIndent(outfile, level)
            outfile.write('wff=model_.wff(\n')
            self.wff.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'wff':
            obj_ = wff.factory()
            obj_.build(child_)
            self.wff = obj_
            obj_.original_tagname_ = 'wff'
# end class notType1


class featuresType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, feature=None):
        self.original_tagname_ = None
        if feature is None:
            self.feature = []
        else:
            self.feature = feature
    def factory(*args_, **kwargs_):
        if featuresType.subclass:
            return featuresType.subclass(*args_, **kwargs_)
        else:
            return featuresType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_feature(self): return self.feature
    def set_feature(self, feature): self.feature = feature
    def add_feature(self, value): self.feature.append(value)
    def insert_feature_at(self, index, value): self.feature.insert(index, value)
    def replace_feature_at(self, index, value): self.feature[index] = value
    def hasContent_(self):
        if (
            self.feature
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='featuresType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='featuresType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='featuresType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='featuresType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='featuresType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for feature_ in self.feature:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfeature>%s</%sfeature>%s' % (namespace_, self.gds_format_string(quote_xml(feature_), input_name='feature'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='featuresType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('feature=[\n')
        level += 1
        for feature_ in self.feature:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(feature_))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'feature':
            feature_ = child_.text
            feature_ = self.gds_validate_string(feature_, node, 'feature')
            self.feature.append(feature_)
# end class featuresType


class eventsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, event=None):
        self.original_tagname_ = None
        if event is None:
            self.event = []
        else:
            self.event = event
    def factory(*args_, **kwargs_):
        if eventsType.subclass:
            return eventsType.subclass(*args_, **kwargs_)
        else:
            return eventsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_event(self): return self.event
    def set_event(self, event): self.event = event
    def add_event(self, value): self.event.append(value)
    def insert_event_at(self, index, value): self.event.insert(index, value)
    def replace_event_at(self, index, value): self.event[index] = value
    def hasContent_(self):
        if (
            self.event
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='eventsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='eventsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='eventsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='eventsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='eventsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for event_ in self.event:
            event_.export(outfile, level, namespace_, name_='event', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='eventsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('event=[\n')
        level += 1
        for event_ in self.event:
            showIndent(outfile, level)
            outfile.write('model_.event(\n')
            event_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'event':
            obj_ = event.factory()
            obj_.build(child_)
            self.event.append(obj_)
            obj_.original_tagname_ = 'event'
# end class eventsType


class temporal_constraintsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, temporal_constraint=None):
        self.original_tagname_ = None
        if temporal_constraint is None:
            self.temporal_constraint = []
        else:
            self.temporal_constraint = temporal_constraint
    def factory(*args_, **kwargs_):
        if temporal_constraintsType.subclass:
            return temporal_constraintsType.subclass(*args_, **kwargs_)
        else:
            return temporal_constraintsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_temporal_constraint(self): return self.temporal_constraint
    def set_temporal_constraint(self, temporal_constraint): self.temporal_constraint = temporal_constraint
    def add_temporal_constraint(self, value): self.temporal_constraint.append(value)
    def insert_temporal_constraint_at(self, index, value): self.temporal_constraint.insert(index, value)
    def replace_temporal_constraint_at(self, index, value): self.temporal_constraint[index] = value
    def hasContent_(self):
        if (
            self.temporal_constraint
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='temporal-constraintsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='temporal-constraintsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='temporal-constraintsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='temporal-constraintsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='temporal-constraintsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for temporal_constraint_ in self.temporal_constraint:
            temporal_constraint_.export(outfile, level, namespace_, name_='temporal-constraint', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='temporal-constraintsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('temporal_constraint=[\n')
        level += 1
        for temporal_constraint_ in self.temporal_constraint:
            showIndent(outfile, level)
            outfile.write('model_.temporal_constraint(\n')
            temporal_constraint_.exportLiteral(outfile, level, name_='temporal-constraint')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'temporal-constraint':
            obj_ = temporal_constraint.factory()
            obj_.build(child_)
            self.temporal_constraint.append(obj_)
            obj_.original_tagname_ = 'temporal-constraint'
# end class temporal_constraintsType


class episodesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, episode=None):
        self.original_tagname_ = None
        if episode is None:
            self.episode = []
        else:
            self.episode = episode
    def factory(*args_, **kwargs_):
        if episodesType.subclass:
            return episodesType.subclass(*args_, **kwargs_)
        else:
            return episodesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_episode(self): return self.episode
    def set_episode(self, episode): self.episode = episode
    def add_episode(self, value): self.episode.append(value)
    def insert_episode_at(self, index, value): self.episode.insert(index, value)
    def replace_episode_at(self, index, value): self.episode[index] = value
    def hasContent_(self):
        if (
            self.episode
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='episodesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='episodesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='episodesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='episodesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='episodesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for episode_ in self.episode:
            episode_.export(outfile, level, namespace_, name_='episode', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='episodesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('episode=[\n')
        level += 1
        for episode_ in self.episode:
            showIndent(outfile, level)
            outfile.write('model_.episode(\n')
            episode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'episode':
            obj_ = episode.factory()
            obj_.build(child_)
            self.episode.append(obj_)
            obj_.original_tagname_ = 'episode'
# end class episodesType


class chance_constraintsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, chance_constraint=None):
        self.original_tagname_ = None
        if chance_constraint is None:
            self.chance_constraint = []
        else:
            self.chance_constraint = chance_constraint
    def factory(*args_, **kwargs_):
        if chance_constraintsType.subclass:
            return chance_constraintsType.subclass(*args_, **kwargs_)
        else:
            return chance_constraintsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_chance_constraint(self): return self.chance_constraint
    def set_chance_constraint(self, chance_constraint): self.chance_constraint = chance_constraint
    def add_chance_constraint(self, value): self.chance_constraint.append(value)
    def insert_chance_constraint_at(self, index, value): self.chance_constraint.insert(index, value)
    def replace_chance_constraint_at(self, index, value): self.chance_constraint[index] = value
    def hasContent_(self):
        if (
            self.chance_constraint
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='chance-constraintsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='chance-constraintsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='chance-constraintsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='chance-constraintsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='chance-constraintsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for chance_constraint_ in self.chance_constraint:
            chance_constraint_.export(outfile, level, namespace_, name_='chance-constraint', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='chance-constraintsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('chance_constraint=[\n')
        level += 1
        for chance_constraint_ in self.chance_constraint:
            showIndent(outfile, level)
            outfile.write('model_.chance_constraint(\n')
            chance_constraint_.exportLiteral(outfile, level, name_='chance-constraint')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'chance-constraint':
            obj_ = chance_constraint.factory()
            obj_.build(child_)
            self.chance_constraint.append(obj_)
            obj_.original_tagname_ = 'chance-constraint'
# end class chance_constraintsType


class decision_variablesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, decision_variable=None):
        self.original_tagname_ = None
        if decision_variable is None:
            self.decision_variable = []
        else:
            self.decision_variable = decision_variable
    def factory(*args_, **kwargs_):
        if decision_variablesType.subclass:
            return decision_variablesType.subclass(*args_, **kwargs_)
        else:
            return decision_variablesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_decision_variable(self): return self.decision_variable
    def set_decision_variable(self, decision_variable): self.decision_variable = decision_variable
    def add_decision_variable(self, value): self.decision_variable.append(value)
    def insert_decision_variable_at(self, index, value): self.decision_variable.insert(index, value)
    def replace_decision_variable_at(self, index, value): self.decision_variable[index] = value
    def hasContent_(self):
        if (
            self.decision_variable
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='decision-variablesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='decision-variablesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='decision-variablesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='decision-variablesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='decision-variablesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for decision_variable_ in self.decision_variable:
            decision_variable_.export(outfile, level, namespace_, name_='decision-variable', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='decision-variablesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('decision_variable=[\n')
        level += 1
        for decision_variable_ in self.decision_variable:
            showIndent(outfile, level)
            outfile.write('model_.decision_variable(\n')
            decision_variable_.exportLiteral(outfile, level, name_='decision-variable')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'decision-variable':
            obj_ = decision_variable.factory()
            obj_.build(child_)
            self.decision_variable.append(obj_)
            obj_.original_tagname_ = 'decision-variable'
# end class decision_variablesType


class state_variablesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, state_variable=None):
        self.original_tagname_ = None
        if state_variable is None:
            self.state_variable = []
        else:
            self.state_variable = state_variable
    def factory(*args_, **kwargs_):
        if state_variablesType.subclass:
            return state_variablesType.subclass(*args_, **kwargs_)
        else:
            return state_variablesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_state_variable(self): return self.state_variable
    def set_state_variable(self, state_variable): self.state_variable = state_variable
    def add_state_variable(self, value): self.state_variable.append(value)
    def insert_state_variable_at(self, index, value): self.state_variable.insert(index, value)
    def replace_state_variable_at(self, index, value): self.state_variable[index] = value
    def hasContent_(self):
        if (
            self.state_variable
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='state-variablesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='state-variablesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='state-variablesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='state-variablesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='state-variablesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for state_variable_ in self.state_variable:
            state_variable_.export(outfile, level, namespace_, name_='state-variable', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='state-variablesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('state_variable=[\n')
        level += 1
        for state_variable_ in self.state_variable:
            showIndent(outfile, level)
            outfile.write('model_.state_variable(\n')
            state_variable_.exportLiteral(outfile, level, name_='state-variable')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'state-variable':
            obj_ = state_variable.factory()
            obj_.build(child_)
            self.state_variable.append(obj_)
            obj_.original_tagname_ = 'state-variable'
# end class state_variablesType


GDSClassesMapping = {
    'and': wff_list,
    'domain': variable_domain,
    'finite-domain': finite_variable_domain,
    'features': featuresType,
    'domainval': domainvalType,
    'episodes': episodesType,
    'boolean-expression': wff_boolean_expression,
    'parameters': parametersType,
    'temporal-constraints': temporal_constraintsType,
    'state-variable-guard': state_variable_guard_boolean_expr,
    'state-variables': state_variablesType,
    'set-bounded-uncertain-duration': set_bounded_uncertain_durationType,
    'assignment': state_variable_assignment,
    'state-variable-at': state_variable_value_at,
    'probabilistic-uncertain-duration': distribution,
    'not': notType1,
    'chance-constraints': chance_constraintsType,
    'continuous-domain': continuous_variable_domain,
    'value': wff_value,
    'events': eventsType,
    'decision-variables': decision_variablesType,
    'initial-state': state,
    'bounded-duration': bounded_durationType,
    'or': wff_list,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'tpns'
        rootClass = tpns
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'tpns'
        rootClass = tpns
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from io import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'tpns'
        rootClass = tpns
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'tpns'
        rootClass = tpns
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from tpn import *\n\n')
        sys.stdout.write('import tpn as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "bounded_durationType",
    "chance_constraint",
    "chance_constraintsType",
    "continuous_variable_domain",
    "decision_variable",
    "decision_variable_equals",
    "decision_variablesType",
    "dispatchable_guarded_tn_member",
    "distribution",
    "domainType",
    "domainvalType",
    "duration",
    "episode",
    "episodesType",
    "event",
    "eventsType",
    "featuresType",
    "finite_variable_domain",
    "guard",
    "guard_list",
    "guarded_tn_member",
    "notType",
    "notType1",
    "parametersType",
    "range_",
    "set_bounded_uncertain_durationType",
    "state",
    "state_constraint",
    "state_variable",
    "state_variable_assignment",
    "state_variable_guard_boolean_expr",
    "state_variable_guard_value",
    "state_variable_value_at",
    "state_variablesType",
    "temporal_constraint",
    "temporal_constraintsType",
    "tpn",
    "tpns",
    "variable_domain",
    "wff",
    "wff_boolean_expression",
    "wff_list",
    "wff_value",
    "xs_IDREF",
    "xs_IDREFS"
]
